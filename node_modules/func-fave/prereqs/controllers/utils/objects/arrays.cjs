const { FIF } = require( '../../fif.cjs' );
const { FDEC } = require( '../../fdec.cjs' );
const { FIM } = require( '../../fim.cjs' );
const { FGR } = require( '../../operators/fgr.cjs' );

function arr_has(value, self) {
  return FDEC(
    (
      FIF(
        FGR(self.length, 0)
        ,
        () => 1,
        () => 0,
      )
    )
    ,
    () => {
      return FIF(
        ( self.indexOf(value) > -1 )
        ,
        () => 1,
        () => 0
      );
    },
    () => 0
  );
}

function arr_get(value, self) {
  return FIF(
    ( arr_has(value, self) )
    ,
    () => self[self.indexOf(value)],
    () => 0
  );
}

function arr_zip(self, counter_arr) {
  return FIM(
    () => {
      const container = [];
      for (let i = 0; i < FGR(self, counter_arr, 0).length; i++) {
        let iteration_record = [];
        iteration_record.push(
          FIF(
            ( arr_has(i, self) )
            , 
            () => arr_get(i, self),
            () => null
          ), 
          FIF(
            ( arr_has(i, counter_arr) )
            , 
            () => arr_get(i, counter_arr),
            () => null
          )
        );
        container.push(iteration_record);
      }
    }
  );
}

function arr_multi_zip(self, counter_arrs) {
  const collection = FIM(
    () => {
      const container = []; let counter_arr_idx = -1; let elem_idx = -1
      counter_arrs.push(self);
      for (let counter_arr of counter_arrs) {
        counter_arr_idx += 1;
        let iteration_record = [];
        for (let elem in counter_arr) {
          elem_idx += 1;
          FIM(
            (iteration_record) => {
              iteration_record.push(
                [ counter_arr[counter_arr_idx][elem_idx] ]
              )
            },
            [iteration_record]
          )
        }
        container.push(iteration_record);
      }
      return container
    }
  )

  return collection;
  
}

module.exports = {
  arr_has,
  arr_get,
  arr_zip,
  arr_multi_zip,
};
