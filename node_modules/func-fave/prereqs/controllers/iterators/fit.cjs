//-- Functional ITerator

const { FDEC } = require('../fdec.cjs');
const { FIF } = require( '../fif.cjs' );
const { FIM } = require( '../fim.cjs' );

class Iterator {

  constructor(
    Index,
    Iterand,
    Interval,
    Body,
    History,
    Back,
    End,
    Cont
  ) {

    this.index = Index;
    this.iterand = Iterand;
    this.interval = Interval;
    this.body = Body;
    this.history = History;
    this.back = Back;
    this.end = End;
    this.cont = Cont;
    
  }

  iterationAction = (actionFn, node) => {
    
    return FIM(
      actionFn,
      [node]
    )
  
  }

  iterate = () => {

    return FIM(
      () => {
        
        this.index.set(
          ( this.index.get() + this.interval.get() )
        )

        this.iterand.set(
          this.body.get()[this.index.get()]
        )
        
        return FIF(
          ( this.iterand.get() !== undefined )
          ,
          () => 1,
          () => 0
        );
        
      }
    )
    
  }

  backtrack = () => {

    return FIM(
      () => {
      
        this.index.set(
          ( this.index.get() - this.interval.get() )
        )
  
        this.iterand.set(
          this.body.get()[this.index.get()]
        )

        this.back.set(false)
  
        return FIF(
          ( this.iterand.get() !== undefined )
          ,
          () => 1,
          () => 0
        )
        
      }
    )
    
  }

  iterating = (actionFn, node) => {
    
    const checkForValidIteration = this.iterate();
    
    return FDEC(
      (
        FIF(
          ( this.back.get() )
          ,
          () => 1,
          () => 0
        )
      )
      ,
      () => {
        
        return this.backtracking(
          actionFn, 
          node
        )
        
      },
      () => {

        return FDEC(
          (
            FIF(
              ( this.cont.get() )
              ,
              () => 1,
              () => 0
            )
          )
          ,
          () => {
            return FIM(
              () => {

                this.cont.set(false)
                
                this.history.set(
                  this.history.get().slice(0, -1)
                )
                
                this.backtrack()
                
                return this.iterating(
                  actionFn, 
                  node
                )
                
              }
            )
          },
          () => {
            return FIF(
              ( this.end.get() )
              ,
              () => {

                return FIF(
                  ( this.backtrack() )
                  ,
                  () => this.history.get(),
                  () => this.history.get()
                )

              },
              () => {

                return FIF(
                  ( checkForValidIteration )
                  ,
                  () => {

                    const iterationResult = this.iterationAction(
                      actionFn,
                      node
                    )

                    this.history.get().push(
                      iterationResult
                    )

                    return this.iterating(
                      actionFn,
                      node
                    )

                  },
                  () => this.history.get()
                )

              }
            )
          }
        )
        
      }
    )
    
  }

  backtracking = (actionFn, node) => {
    
    const checkForValidBacktrack = this.backtrack();
    return FIF(
      ( checkForValidBacktrack )
      ,
      () => {

        const backtrackResult = this.iterationAction(
          actionFn,
          node
        )
        
        this.history.get()[-1] = backtrackResult;

        const iterationResult = this.iterating(
          actionFn,
          node
        )

        this.history.get().push(
          iterationResult
        )

        this.history.set(
          this.history.get().slice(0, -1)
          // removes circular references
        )

        return iterationResult;
        
      },
      () => this.history.get()
    )
    
  }
  
}

function createIterator(
  Index,
  Iterand,
  Interval,
  Body,
  History,
  Back,
  End,
  Cont
) {

  return new Iterator(
    Index,
    Iterand,
    Interval,
    Body,
    History,
    Back,
    End,
    Cont
  )
  
}

module.exports = {
  createIterator
}